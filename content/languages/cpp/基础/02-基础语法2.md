---
title: "基础语法2"
weight: 2
---

## 类型

### 基础数据类型列表

[types](https://en.cppreference.com/w/cpp/language/types.html)

| Data types               | Notes |
|--------------------------|-------|
| `long double`            |       |
| `double`                 |       |
| `float`                  |       |
| `unsigned long long int` | (synonymous with `unsigned long long`) |
| `long long int`          | (synonymous with `long long`) |
| `unsigned long int`      | (synonymous with `unsigned long`) |
| `long int`               | (synonymous with `long`) |
| `unsigned int`           | (synonymous with `unsigned`) |
| `int`                    |       |
| `unsigned short int`     | (synonymous with `unsigned short`) |
| `short int`              | (synonymous with `short`) |
| `unsigned char`          |       |
| `char` and `signed char` |       |
| `bool`                   |       |

### 超大整数可使用的第三方库

[multiprecision](https://github.com/boostorg/multiprecision/)

使用 cpp_int 类

```cpp
#include <boost/multiprecision/cpp_int.hpp>
#include <iostream>
using namespace std;
using boost::multiprecision::cpp_int;
	
int main() {
   const cpp_int value1{"100000000000000000000000000000"};
   const cpp_int value2{9223372036854775807LL};//这个long long整数最大值可以通过 std::numeric_limits<long long>::max()自动获取最大值，头文件在 limits下
   const int value3{3}; 
   
   cout << "INITIAL VALUES"
      << "\ncpp_int value1: " << value1
      << "\ncpp_int value2: " << value2
      << "\n    int value3: " << value3;

   cout << "\n\nADD, SUBTRACT AND MULTIPLY CPP_INT OBJECTS"
      << "\nvalue1 + value2: " << value1 + value2
      << "\nvalue1 - value2: " << value1 - value2
      << "\nvalue1 * value2: " << value1 * value2;
   
   cout << "\n\nMULTIPLY A CPP_INT OBJECT BY INT VALUES"
      << "\nvalue1 * value3: " << value1 * value3
      << "\n    value1 * 17: " << value1 * 17 << "\n";
}
```

### double

```cpp
#include <format> 
#include <iostream>
#include <cmath> // 数学相关头文件
using namespace std;

int main() {
   double principal{1000.00}; // 初始化 double 类型
   double rate{0.05};

   cout << format("Initial principal: {:>7.2f}\n", principal)
        << format("    Interest rate: {:>7.2f}\n", rate); //格式化中占位符内容说明 : 格式说明符， > 右对齐， 7 字段宽度字符数， 2 小数点位数，  f浮点数类型

   cout << format("\n{}{:>20}\n", "Year",  "Amount on deposit");

   for (int year{1}; year <= 10; ++year) {                           
      // pow 幂运算
      double amount{principal * pow(1.0 + rate, year)} ;             
      // d 十进制                                                              
      cout << format("{:>4d}{:>20.2f}\n", year, amount);
   }                                                                 
}
```

浮点数多精度可使用 boost 库的 cpp_dec_float_50 类，可参考：

{{< remote-code url="https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/cpp/cpp_20_study/examples/lesson04/fig04_17.cpp" lang="cpp" title="cpp_dec_float_50" >}}


### 字符串

```cpp
#include <iostream>
#include <string>  // 引入字符串头文件
using namespace std; //引入 std 命名空间，这样标准空间中其他方法不需要都写上命名空间

int main() {
   string s1{"happy"}; // 字符串初始化为 happy
   string s2{" birthday"};
   string s3; // 空字符串
              
   cout << "s1: \"" << s1 << "\"; length: " << s1.length()
      << "\ns2: \"" << s2 << "\"; length: " << s2.length()
      << "\ns3: \"" << s3 << "\"; length: " << s3.length();

   // 字符串比较 == and !=
   cout << "\n\nThe results of comparing s2 and s1:" << boolalpha //由于C++比较的结果为数字，所以增加这个变量可以显示false，or true。
      << "\ns2 == s1: " << (s2 == s1)
      << "\ns2 != s1: " << (s2 != s1); //比较值显示 0 为 false ，非 0 为true
   
   cout << "\n\nTesting s3.empty():\n";

   if (s3.empty()) { // 字符串判断是否为空
      cout << "s3 is empty; assigning to s3;\n";
      s3 = s1 + s2; // 字符串拼接
      cout << "s3: \"" << s3 << "\"";
   } 

   cout << "\n\ns1 starts with \"ha\": " << s1.starts_with("ha") << "\n"; //判断字符串是否以 ha 开头
   cout << "s2 starts with \"ha\": " << s2.starts_with("ha") << "\n";
   cout << "s1 ends with \"ay\": " << s1.ends_with("ay") << "\n";//判断字符串是否以 ay 结尾
   cout << "s2 ends with \"ay\": " << s2.ends_with("ay") << "\n"; //boolalpha 设置依然有效，这是粘性设置。

   cout  << noboolalpha << "s1 starts with \"ha\": " << s1.starts_with("ha") << "\n"; //noboolalpha 取消设置 true or false 文本显示。
}
//g++ string_test.cpp --std=c++20 //需要指定C++20，否则会报错，默认非20标准
```

## 函数

- [cmath](https://en.cppreference.com/w/cpp/numeric/math.html)
- [C++ standard document](http://wg21.link/n4861)
- [math function](https://en.cppreference.com/w/cpp/numeric/special_functions)

cmath 头文件中的部分函数说明

### 常用数学函数表
| Function | Description | Example |
|---|---|---|
| `ceil(x)` | 向上取整，返回不小于 x 的最小整数 | `ceil(9.2)` is `10.0`<br>`ceil(-9.8)` is `-9.0` |
| `cos(x)` | 计算 x 的余弦值（x 以弧度为单位） | `cos(0.0)` is `1.0` |
| `exp(x)` | 计算指数函数 \(e^x\) | `exp(1.0)` is `2.718282`<br>`exp(2.0)` is `7.389056` |
| `fabs(x)` | 计算 x 的绝对值 | `fabs(5.1)` is `5.1`<br>`fabs(0.0)` is `0.0`<br>`fabs(-8.76)` is `8.76` |
| `floor(x)` | 向下取整，返回不大于 x 的最大整数 | `floor(9.2)` is `9.0`<br>`floor(-9.8)` is `-10.0` |
| `fmod(x, y)` | 计算 x 除以 y 的浮点数余数 | `fmod(2.6, 1.2)` is `0.2` |
| `log(x)` | 计算 x 的自然对数（以 e 为底） | `log(2.718282)` is `1.0`<br>`log(7.389056)` is `2.0` |
| `log10(x)` | 计算 x 的常用对数（以 10 为底） | `log10(10.0)` is `1.0`<br>`log10(100.0)` is `2.0` |
| `pow(x, y)` | 计算 x 的 y 次幂（\(x^y\)） | `pow(2, 7)` is `128`<br>`pow(9, .5)` is `3` |
| `sin(x)` | 计算 x 的正弦值（x 以弧度为单位） | `sin(0.0)` is `0` |
| `sqrt(x)` | 计算 x 的平方根（x 必须非负） | `sqrt(9.0)` is `3.0` |
| `tan(x)` | 计算 x 的正切值（x 以弧度为单位） | `tan(0.0)` is `0` |

```cpp
#include <iostream>

using namespace std;

int maximum(int x, int y, int z); // 函数前置声明 

int main() {
   cout << "Enter three integer values: ";
   int int1, int2, int3;
   cin >> int1 >> int2 >> int3;

   cout << "The maximum integer value is: " 
      << maximum(int1, int2, int3) << '\n';
}

//函数实现
int maximum(int x, int y, int z) {
   int maximumValue{x}; // 初始化变量

   if (y > maximumValue) {
      maximumValue = y;
   }

   if (z > maximumValue) {
      maximumValue = z;
   }

   return maximumValue;
}
```

### random

```cpp
#include <iostream>
#include <random>
using namespace std;

int main() {
   // 随机数生成引擎（现在使用的是其中一种），需要种子才能随机，当前为伪随机
   default_random_engine engine{};

   // 指定的分布范围，概率都是相等的
   uniform_int_distribution randomDie{1, 6};

   // 10 次查看生成的结果
   for (int counter{1}; counter <= 10; ++counter) {
      cout << randomDie(engine) << " "; 
   } 

   cout << '\n';
} 
```

```cpp
#include <iostream>
#include <random>

using namespace std;

int main() {
   unsigned int seed{0}; // 初始化一个种子

   cout << "Enter seed: ";
   cin >> seed;

   default_random_engine engine{seed}; // 使用种子
   
   //random_device rd; // 随机设备对象
   //default_random_engine engine{rd()}; // rd() produces a seed 
   uniform_int_distribution randomDie{1, 6};

   for (int counter{1}; counter <= 10; ++counter) {
      cout << randomDie(engine) << " ";
   } 

   cout << '\n';
} 
```

### inline 函数

- [C++ Core Guidelines 原文](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html#Rf-inline)
- [ISO C++ FAQ](https://isocpp.org/wiki/faq/inline-functions)

inline 函数的作用：

- 可能提高性能。因为优化器可以在程序上集成调用的代码——将调用的代码优化到调用程序中。 
- inline函数可能会使其更快。
- inline函数可能会使其变慢。
- inline函数可能会使其变大。
- inline函数可能会使其变小。
- inline函数可能会导致粉碎。
- inline函数可能会防止崩溃。
- inline函数可能会增加缓存错过的次数。
- inline函数可能会减少缓存错误的数量。
- inline功能可能与速度无关。

inline 函数与宏的区别：

- 安全：参数只求值一次，类型安全。宏在展开时会直接替换文本，导致传入的参数可能被计算多次。
- 可调试：在调试模式下可像普通函数一样调试（取决于编译器选项）。宏调试困难。
- 语义清晰：遵循 C++ 函数调用规则，行为可预测。宏不受作用域限制。
- 性能相当：现代编译器对 inline 函数的优化效果与宏相当，甚至更好（通过过程集成等优化）。

```cpp
#include <iostream> 
using namespace std;

inline double cube(double side) { // inline func   
   return side * side * side; // 返回立方值
}                                               

int main() {
   double sideValue; 
   cout << "Enter the side length of your cube: ";
   cin >> sideValue; 

   cout << "Volume of cube with side " 
      << sideValue << " is " << cube(sideValue) << '\n';
} 
```

```cpp
[[nodiscard]] //C++17 引入，它是专门用于强制提醒开发者不要忽略函数返回值的标准化语法，核心作用是提升代码健壮性、避免因遗漏返回值导致的逻辑错误。
int cube(int x) {
   return x * x * x;
}

int main() {
   cube(10); // generates a compiler warning
}
```

### 函数参数

#### 值传递

拷贝副本

```cpp
#include <iostream>
using namespace std;

int squareByValue(int number);
   
int main() {
   int x{2};

   cout << "x = " << x << " before squareByValue\n";
   cout << "Value returned by squareByValue: " 
      << squareByValue(x) << '\n';  
   cout << "x = " << x << " after squareByValue\n\n";
} 
     
int squareByValue(int number) {                               
   return number *= number;
}
```

#### 引用传递

传递地址，减少数据拷贝

```cpp
#include <iostream>
using namespace std;
   
void squareByReference(int& numberRef);
   
int main() {
   int z{4};

   cout << "z = " << z << " before squareByReference\n";
   squareByReference(z);
   cout << "z = " << z << " after squareByReference\n";
}                                                          
           
void squareByReference(int& numberRef) {                 
   numberRef *= numberRef;
}
```

#### 默认实参

- 有默认实参值，不传递参数值，则使用默认参数值
- 默认实参在定义时指定即可，实现时参数不需要指定参数值

```cpp
#include <iostream>
using namespace std;

int boxVolume(int length = 1, int width = 1, int height = 1); 
 
int main() {
   cout << "The default box volume is: " << boxVolume();
   
   cout << "\n\nThe volume of a box with length 10,\n"
      << "width 1 and height 1 is: " << boxVolume(10);
        
   cout << "\n\nThe volume of a box with length 10,\n" 
      << "width 5 and height 1 is: " << boxVolume(10, 5);
   
   cout << "\n\nThe volume of a box with length 10,\n"
      << "width 5 and height 2 is: " << boxVolume(10, 5, 2)
      << '\n';
} 

int boxVolume(int length, int width, int height) {                                       
   return length * width * height;                              
} 
```

### 函数重载

- 函数的返回值不区分函数签名，所以不是重载的条件。
- [cppreference 对重载决议有完整的规则说明](https://en.cppreference.com/w/cpp/language/overload_resolution)
- 编译器底层会对函数名重整，编译器不同,重整方式不同，一般会把函数参数加到函数名中用于区分调用的函数。

```cpp
#include <iostream>
using namespace std;

int square(int x) {                            
   cout << "square of integer " << x << " is ";
   return x * x;                               
} 

double square(double y) {                     
   cout << "square of double " << y << " is "; 
   return y * y;                               
} 

int main() {
   cout << square(7);
   cout << '\n';
   cout << square(7.5);
   cout << '\n';
} 
```

### 函数模板

可以自动接收不同参数类型，不需要写多个不同类型的重复代码

```cpp
#include <iostream>
using namespace std;

template <typename T>  // or template <class T>      
T maximum(T value1, T value2, T value3) {                 
   T maximumValue{value1};

   if (value2 > maximumValue) {                           
      maximumValue = value2;                               
   }                                                        

   if (value3 > maximumValue) {                           
      maximumValue = value3;                               
   }                                                        
   
   return maximumValue;                                    
} 

int main() {
   cout << "Input three integer values: ";
   int int1, int2, int3;
   cin >> int1 >> int2 >> int3;

   cout << "The maximum integer value is: "
      << maximum(int1, int2, int3);        

   cout << "\n\nInput three double values: ";
   double double1, double2, double3;
   cin >> double1 >> double2 >> double3;

   cout << "The maximum double value is: "
      << maximum(double1, double2, double3);

   cout << "\n\nInput three characters: ";
   char char1, char2, char3;
   cin >> char1 >> char2 >> char3;

   cout << "The maximum character value is: "
      << maximum(char1, char2, char3) << '\n';
}
```

## 递归

斐波拉契数列：

```cpp
#include <format>  
#include <iostream>
using namespace std;

long fibonacci(long number); 

int main() {
   for (int counter{0}; counter <= 10; ++counter) {
      cout << format("fibonacci({}) = {}\n", 
         counter, fibonacci(counter));
   }

   cout << format("\nfibonacci(20) = {}\n", fibonacci(20))
      << format("fibonacci(30) = {}\n", fibonacci(30))
      << format("fibonacci(35) = {}\n", fibonacci(35));
} 

long fibonacci(long number) {            
   if ((0 == number) || (1 == number)) {
      return number;                                       
   }                                                       
   else {                              
      return fibonacci(number - 1) + fibonacci(number - 2);
   }                                                       
}  
```

cpp_int 阶乘参考：

{{< remote-code url="https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/cpp/cpp_20_study/examples/lesson05/fig05_14.cpp" lang="cpp" title="cpp_int 阶乘" >}}

## 作用域

- static 静态局部变量在第一次初始化后保存在内存，以后可重复利用不需要再初始化
- 局部变量作用域结束后即销毁
- 全局变量在整个程序的运行时期都有效

```cpp
#include <iostream>
using namespace std;

void useLocal();
void useStaticLocal();
void useGlobal();

int x{1}; //全局变量

int main() {
   cout << "global x in main is " << x << '\n'; 

   const int x{5};// main 函数内局部变量

   cout << "local x in main's outer scope is " << x << '\n';
 
   {                               
      const int x{7}; //块内局部变量
                                                                  
      cout << "local x in main's inner scope is " << x << '\n';   
   }                                                               
 
   cout << "local x in main's outer scope is " << x << '\n';

   useLocal();
   useStaticLocal();
   useGlobal();
   useLocal();
   useStaticLocal();
   useGlobal();

   cout << "\nlocal x in main is " << x << '\n';
} 

void useLocal() {
   int x{25}; // useLocal 函数内局部变量

   cout << "\nlocal x is " << x << " on entering useLocal\n";
   ++x;
   cout << "local x is " << x << " on exiting useLocal\n";
} 

void useStaticLocal() {
   static int x{50}; //静态局部变量，第一次调用，则保存在内存，直到程序结束，只能在这个函数内调用此变量。

   cout << "\nlocal static x is " << x 
      << " on entering useStaticLocal\n";
   ++x; 
   cout << "local static x is " << x 
      << " on exiting useStaticLocal\n";
} 

void useGlobal() {
   cout << "\nglobal x is " << x << " on entering useGlobal\n";
   x *= 10; //使用全局变量
   cout << "global x is " << x << " on exiting useGlobal\n";
} 
```

## Vigenère 密码

- **Vigenère 密码（Vignère secret key cipher）**：一种多表替换密码，通过使用一系列凯撒密码组成加密字母表来加密明文，是古典密码学中最著名的算法之一。

| 链接 | 主题 |
|---|---|
| [https://en.wikipedia.org/wiki/Vigenère_cipher](https://en.wikipedia.org/wiki/Vigenère_cipher) | Vigenère 密码的详细原理、历史和破解方法 |
| [https://en.wikipedia.org/wiki/Cryptography#History_of_cryptography_and_cryptanalysis](https://en.wikipedia.org/wiki/Cryptography#History_of_cryptography_and_cryptanalysis) | 密码学的完整历史，从古典密码到现代密码学的演变 |
| [https://www.binance.vision/security/history-of-cryptography](https://www.binance.vision/security/history-of-cryptography) | 以区块链和加密货币为背景的密码学历史介绍 |
| [在线凯撒密码工具](https://cryptii.com/pipes/caesar-cipher) | 在线凯撒密码工具 |
| [cryptii](https://github.com/cryptii/cryptii) | 开源工具 |

示例代码参考：


{{< remote-code url="https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/cpp/cpp_20_study/examples/lesson05/fig05_18.cpp" lang="cpp" title="Vigenère 密码示例" >}}
