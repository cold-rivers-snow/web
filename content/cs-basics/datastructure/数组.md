---
title: "数组（顺序存储）"
date: 2025-10-27T15:04:14+08:00
author: ["寒江雪"]

categories:
- 数据结构

description: ""
summary: "数据结构学习笔记"
draft: false
math: true
comments: true
image:
toc: true
showToc: true
TocOpen: true
readingTime: true
autonumbering: true
hidemeta: false
disableShare: true
searchHidden: false
showbreadcrumbs: true
mermaid: true
style:
    background: "white"
    color: "black"
license: 
    enabled: false
    default: Licensed under CC BY-NC-SA 4.0
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---

**数据结构本质上只有两种，一种叫数组，一种叫链表。**其他的都是它们俩的衍生。

**算法本质就是穷举。**花里胡哨的算法名称都只是名词而已，它们做的事情都本质都是穷举。

算法对数据的操作就是增删改查（CURD）
时间复杂度：估算的是最坏的情况；是算法的执行效率，通常我们要去依靠循环次数和嵌套次数
空间复杂度：使用的变量开辟的空间的情况（说白了，我们只关注我们在堆栈上新创建了哪些变量，不需要关注函数输入的变量）；是算法的内存消耗，通常我们要去依靠算法开辟的空间和数据结构

## 静态数组

类似于

```cpp
int arr[5]
```

数组名 arr 是一个指针的首地址，开辟了一段 5 * sizeof(int) 长度这么大的地址，用于存储数据。一旦开辟了就不能顺序扩容，必现开辟一段更长的地址，通过数据搬迁的方式增加数据。

- 增：
  - 空间有空余的情况下
    - 在末尾增加，时间复杂度为 O(1)
    - 在中间（非末尾）增加，时间复杂度为 O(n)
  - 空间无空余的情况下（需要搬迁数据）
    - 在末尾增加，时间复杂度为 O(n)
    - 在中间（非末尾）增加，时间复杂度为 O(n)
- 删：
  - 在末尾删除，时间复杂度为 O(1)
  - 在中间（非末尾）删除，时间复杂度为 O(n)，需要搬迁数据
- 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)O(1)。
- 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)O(1)。

## 动态数组

动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已。
c++中就是 vector

- 自动扩缩容
- 索引越界的检查
- 删除元素谨防内存泄漏

{{< remote-code url="https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/datastruct/array.cpp" lang="cpp" title="动态数组" >}}


## 环形数组

**数组就是一块线性连续的内存空间，这一点很重要。**

环形数组技巧利用求模（余数）运算，将普通数组变成逻辑上的环形数组，可以让我们用 O(1) 的时间在数组头部增删元素。

环形数组的关键在于，它维护了两个指针 start 和 end，start 指向第一个有效元素的索引，end 指向最后一个有效元素的下一个位置索引。

这样，当我们在数组头部添加或删除元素时，只需要移动 start 索引，而在数组尾部添加或删除元素时，只需要移动 end 索引。当 start, end 移动超出数组边界（< 0 或 >= arr.length）时，我们可以通过求模运算 % 让它们转一圈到数组头部或尾部继续工作，这样就实现了环形数组的效果。

[start, end) 区间。理论上，可以随意设计区间的开闭，但一般设计为左闭右开区间是最方便处理的。

如果设置为两端都开的区间，那么让 end 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就已经包含了一个元素。需要代码特殊处理，编码需要考虑边界问题。

{{< remote-code url="https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/datastruct/cycle_array.cpp" lang="cpp" title="环形数组" >}}


## 位图

位图是一种节省空间的数据结构，用单个比特位（bit）的 0/1 标记元素是否存在。

通过 “1 比特对应 1 个元素状态” 的设计，极致压缩内存占用，比如存储 1000 个元素的存在状态，布尔数组需 1000 字节，位图仅需约 125 字节（1000/8）。

## Reference

https://labuladong.online/algo/data-structure-basic/cycle-array

https://labuladong.online/algo/data-structure-basic/array-basic

https://labuladong.online/algo/essential-technique/array-two-pointers-summary/
