{"/web/about/":{"data":{"":"","关于作者#关于作者":"寒江雪，专注于 C++, 存储等相关领域。","关于本站#关于本站":"这里是寒江雪的技术图谱，记录我的学习与成长。"},"title":"关于"},"/web/cs-basics/datastructure/%E6%95%B0%E7%BB%84/":{"data":{"":"**数据结构本质上只有两种，一种叫数组，一种叫链表。**其他的都是它们俩的衍生。\n**算法本质就是穷举。**花里胡哨的算法名称都只是名词而已，它们做的事情都本质都是穷举。\n算法对数据的操作就是增删改查（CURD） 时间复杂度：估算的是最坏的情况；是算法的执行效率，通常我们要去依靠循环次数和嵌套次数 空间复杂度：使用的变量开辟的空间的情况（说白了，我们只关注我们在堆栈上新创建了哪些变量，不需要关注函数输入的变量）；是算法的内存消耗，通常我们要去依靠算法开辟的空间和数据结构","reference#Reference":"https://labuladong.online/algo/data-structure-basic/cycle-array\nhttps://labuladong.online/algo/data-structure-basic/array-basic\nhttps://labuladong.online/algo/essential-technique/array-two-pointers-summary/","位图#位图":"位图是一种节省空间的数据结构，用单个比特位（bit）的 0/1 标记元素是否存在。\n通过 “1 比特对应 1 个元素状态” 的设计，极致压缩内存占用，比如存储 1000 个元素的存在状态，布尔数组需 1000 字节，位图仅需约 125 字节（1000/8）。","动态数组#动态数组":"动态数组底层还是静态数组，只是自动帮我们进行数组空间的扩缩容，并把增删查改操作进行了封装，让我们使用起来更方便而已。 c++中就是 vector\n自动扩缩容 索引越界的检查 删除元素谨防内存泄漏 动态数组 查看源文件 ↗ 正在加载代码... https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/datastruct/array.cpp\n❌ 加载失败 请检查网络连接或URL是否正确\n展开 折叠","环形数组#环形数组":"数组就是一块线性连续的内存空间，这一点很重要。\n环形数组技巧利用求模（余数）运算，将普通数组变成逻辑上的环形数组，可以让我们用 O(1) 的时间在数组头部增删元素。\n环形数组的关键在于，它维护了两个指针 start 和 end，start 指向第一个有效元素的索引，end 指向最后一个有效元素的下一个位置索引。\n这样，当我们在数组头部添加或删除元素时，只需要移动 start 索引，而在数组尾部添加或删除元素时，只需要移动 end 索引。当 start, end 移动超出数组边界（\u003c 0 或 \u003e= arr.length）时，我们可以通过求模运算 % 让它们转一圈到数组头部或尾部继续工作，这样就实现了环形数组的效果。\n[start, end) 区间。理论上，可以随意设计区间的开闭，但一般设计为左闭右开区间是最方便处理的。\n如果设置为两端都开的区间，那么让 end 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就已经包含了一个元素。需要代码特殊处理，编码需要考虑边界问题。\n环形数组 查看源文件 ↗ 正在加载代码... https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/datastruct/cycle_array.cpp\n❌ 加载失败 请检查网络连接或URL是否正确\n展开 折叠","静态数组#静态数组":"类似于\nint arr[5] 数组名 arr 是一个指针的首地址，开辟了一段 5 * sizeof(int) 长度这么大的地址，用于存储数据。一旦开辟了就不能顺序扩容，必现开辟一段更长的地址，通过数据搬迁的方式增加数据。\n增： 空间有空余的情况下 在末尾增加，时间复杂度为 O(1) 在中间（非末尾）增加，时间复杂度为 O(n) 空间无空余的情况下（需要搬迁数据） 在末尾增加，时间复杂度为 O(n) 在中间（非末尾）增加，时间复杂度为 O(n) 删： 在末尾删除，时间复杂度为 O(1) 在中间（非末尾）删除，时间复杂度为 O(n)，需要搬迁数据 查：给定指定索引，查询索引对应的元素的值，时间复杂度 O(1)O(1)。 改：给定指定索引，修改索引对应的元素的值，时间复杂度 O(1)O(1)。"},"title":"数组（顺序存储）"},"/web/friends/":{"data":{"":"","友情链接#友情链接":"欢迎互换友链！\nExample Site - 这是一个示例友链。"},"title":"友链"},"/web/industry/":{"data":{"":"这里包含了云原生、DevOps 以及人工智能等前沿行业方向的学习资料。"},"title":"行业方向"},"/web/industry/ai/":{"data":{"":"人工智能相关学习笔记。"},"title":"人工智能 (AI)"},"/web/languages/":{"data":{"":"这里记录我学习各种编程语言的笔记，包括 C++ 的底层机制、Rust 的所有权模型等。"},"title":"编程语言"},"/web/languages/cpp/":{"data":{"":"这里主要基于 C++11/14/17/20 标准，从基础、进阶、提高等。","书籍#书籍":"《C++程序设计：面向对象的自然方法》 《C++ 20 程序员指南：面向对象的自然方法》 https://deitel.com/cpphtp11architecture","相关第三方库#相关第三方库":"https://github.com/Microsoft/GSL","相关资料持续更新#相关资料（持续更新）":"学习、阅读等相关内容都在这里引用，并更新相关知识点。","网址#网址":"http://cplusplus.com https://cppreference.com/ https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/n4861.pdf https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html https://www.open-std.org","视频#视频":"https://www.bilibili.com/video/BV1qg1rBdEcB/?spm_id_from=333.788.videopod.sections\u0026vd_source=3cc5c63659274d24dd07e99dc80bc98d"},"title":"C++"},"/web/languages/cpp/%E5%9F%BA%E7%A1%80/01-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/":{"data":{"":"","break#break":"跳出本次循环。 跳出 switch（示例见 switch case 章节）。 #include using namespace std; int main() { int count; for (count = 1; count \u003c= 10; ++count) { if (count == 5) { break; // 跳出循环 } cout \u003c\u003c count \u003c\u003c \" \"; } cout \u003c\u003c \"\\nBroke out of loop at count = \" \u003c\u003c count \u003c\u003c \"\\n\"; }","c20-关键字#C++20 关键字":"char8_t、concept、char16_t、consteval、constinit、co_await、co_return、co_yield、requires","c20新增关键字及特殊标识符#C++20新增关键字及特殊标识符":"","continue#continue":"跳过后面的内容，进入下一个循环。\n#include using namespace std; int main() { for (int count{1}; count \u003c= 10; ++count) { if (count == 5) { continue; // 进入下个循环 } cout \u003c\u003c count \u003c\u003c \" \"; } cout \u003c\u003c \"\\nUsed continue to skip printing 5\\n\"; }","c和c共有的关键字#C和C++共有的关键字":"关键字列表 asm、auto、break、case、char const、continue、default、do、double else、enum、extern、float、for goto、if、inline、int、long register、return、short、signed、sizeof static、struct、switch、typedef、union unsigned、void、volatile、while","c独有的关键字#C++独有的关键字":"关键字列表 alignas、alignof、and、and_eq、bitand bitor、bool、catch、char16_t、char32_t class、compl、const_cast、constexpr、decltype delete、dynamic_cast、explicit、export、false friend、mutable、namespace、new、noexcept not、not_eq、nullptr、operator、or or_eq、private、protected、public、reinterpret_cast static_assert、static_cast、template、this、thread_local throw、true、try、typeid、typename using、virtual、wchar_t、xor、xor_eq","c算术运算符对应表#C++算术运算符对应表":"操作 算术运算符 C++表达式 加法 + f + 7 减法 - p - c 乘法 * b * m 除法 / x / y 取余（求模） % r % s","do-while-循环#do while 循环":"#include using namespace std; int main() { int counter{1}; do { cout \u003c\u003c counter \u003c\u003c \" \"; ++counter; } while (counter \u003c= 10); // end do...while cout \u003c\u003c \"\\n\"; }","docker#docker":"容器可以使代码在相同的环境下都能正确运行。\ndocker run --platform linux/amd64 --rm -it -v \"(pwd)\":/usr/src gcc:latest","for-循环#for 循环":"计数\n#include using namespace std; int main() { // for 迭代，初始化表达式；条件表达式；递增表达式 for (int counter{1}; counter \u003c= 10; ++counter) { cout \u003c\u003c counter \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } #include #include using namespace std; int main() { int total{0}; // 每次步长 2 ，计数20内的偶数和 for (int number{2}; number \u003c= 20; number += 2) { total += number; } // c++20 的format 方式，格式字面量，{} 用于占位符，被后面变量替换。 cout \u003c\u003c format(\"Sum is {}\\n\", total); }","heading#\u0026amp;\u0026amp;":"expression1 expression2 expression1 \u0026\u0026 expression2 false false false false true false true false false true true true","heading-1#||":"expression1 expression2 expression1 || expression2 false false false false true true true false true true true true 短路效应：如果表达式 1 为 true ，则不需要运行表达式 2 的判断。","heading-2#!":"expression1 !expression1 !false true !true false","hello-world#hello world":"#include //引入头文件 int main() { // C++程序入口（main 函数）， int 为返回类型 std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; //标准输出，语句，以分号结尾。 return 0; //返回值 }","if-else#if else":"if (expr) { } if (expr) { } else { } if (expr) { } else if (expr) { } else if (expr) { } else if (expr) { } else { }","switch-case#switch case":"#include #include using namespace std; int main() { double total{0.0}; int gradeCounter{0}; int aCount{0}; int bCount{0}; int cCount{0}; int dCount{0}; int fCount{0}; cout \u003c\u003c \"Enter the integer grades in the range 0-100.\\n\" \u003c\u003c \"Type the end-of-file indicator to terminate input:\\n\" \u003c\u003c \" On UNIX/Linux/macOS type d then press Enter\\n\" \u003c\u003c \" On Windows type z then press Enter\\n\"; int grade; while (cin \u003e\u003e grade) { total += grade; ++gradeCounter; switch (grade / 10) { case 9: case 10: ++aCount; break; case 8: ++bCount; break; case 7: ++cCount; break; case 6: ++dCount; break; default: ++fCount; break; } // end switch } // end while cout \u003c\u003c \"\\nGrade Report:\\n\"; if (gradeCounter != 0) { double average{total / gradeCounter}; cout \u003c\u003c format(\"Total of the {} grades entered is {}\\n\", gradeCounter, total) \u003c\u003c format(\"Class average is {:.2f}\\n\\n\", average) \u003c\u003c \"Summary of student's grades:\\n\" \u003c\u003c format(\"A: {}\\nB: {}\\nC: {}\\nD: {}\\nF: {}\\n\", aCount, bCount, cCount, dCount, fCount); } else { cout \u003c\u003c \"No grades were entered\\n\"; } } [[fallthrough]] 属性（C++17 引入），它是专门用于 switch 语句中明确标识 “穿透” 行为的标准化语法，核心作用是消除编译器的穿透警告、提升代码可读性。\n#include using namespace std; int main() { int num = 1; switch (num) { case 1: cout \u003c\u003c \"处理case 1的前置逻辑\\n\"; [[fallthrough]]; // 显式声明穿透（无警告） case 2: cout \u003c\u003c \"处理case 1和case 2的通用逻辑\\n\"; break; // 终止穿透 case 3: cout \u003c\u003c \"处理case 3\\n\"; // 无break，也无fallthrough → 编译器会报穿透警告 default: cout \u003c\u003c \"处理默认情况\\n\"; } return 0; }","while-循环#while 循环":"while(expr) { } 示例 1：while循环\n#include using namespace std; int main() { int total{0}; // 初始化 int gradeCounter{1}; while (gradeCounter \u003c= 10) { // while 循环 10 次 cout \u003c\u003c \"Enter grade: \"; int grade; cin \u003e\u003e grade; // 输入 grade total = total + grade; // 加 grade 到 total gradeCounter = gradeCounter + 1; // gradeCounter 次数加 1 } int average{total / 10}; // 求平均 cout \u003c\u003c \"\\nTotal of all 10 grades is \" \u003c\u003c total; cout \u003c\u003c \"\\nClass average is \" \u003c\u003c average \u003c\u003c \"\\n\"; } 示例2: while + if else\n#include #include // 输出流格式化相关头文件 using namespace std; int main() { double total{0.0}; // 初始化 double 类型变量，浮点数为近似表示 int gradeCounter{0}; // 初始化整数类型 cout \u003c\u003c \"Enter grade or -1 to quit: \"; int grade; cin \u003e\u003e grade; while (grade != -1) { total = total + grade; // add grade to total gradeCounter = gradeCounter + 1; // 计数 cout \u003c\u003c \"Enter grade or -1 to quit: \"; cin \u003e\u003e grade; } if (gradeCounter != 0) { // 除数非0 double average{total / gradeCounter}; //转换为浮点数 double 类型 cout \u003c\u003c \"\\nTotal of the \" \u003c\u003c gradeCounter \u003c\u003c \" grades entered is \" \u003c\u003c total; cout \u003c\u003c setprecision(2) \u003c\u003c fixed; //定点表示法显示浮点数 cout \u003c\u003c \"\\nClass average is \" \u003c\u003c average \u003c\u003c \"\\n\"; } else { cout \u003c\u003c \"No grades were entered\\n\"; } } 示例3: while + if else 嵌套\n#include using namespace std; int main() { int passes{0}; int failures{0}; int studentCounter{1}; while (studentCounter \u003c= 10) { cout \u003c\u003c \"Enter result (1 = pass, 2 = fail): \"; int result; cin \u003e\u003e result; if (result == 1) { passes = passes + 1; } else { failures = failures + 1; } studentCounter = studentCounter + 1; } cout \u003c\u003c \"Passed: \" \u003c\u003c passes \u003c\u003c \"\\nFailed: \" \u003c\u003c failures \u003c\u003c \"\\n\"; if (passes \u003e 8) { cout \u003c\u003c \"Bonus to instructor!\\n\"; } } 计数\n#include using namespace std; int main() { int counter{1}; // 列表初始化 while (counter \u003c= 10) { // 循环条件 cout \u003c\u003c counter \u003c\u003c \" \"; ++counter; // 自增 } cout \u003c\u003c \"\\n\"; }","三目运算符#三目运算符":"1 == 1 ? true : false; // (expr) ? 正确 ： 错误","关键字#关键字":"","其他特殊标识符#其他特殊标识符":"具有特殊含义的标识符： final、import、module、override、transaction_safe、transaction_safe_dynamic 实验性关键字： atomic_cancel、atomic_commit、atomic_noexcept、reflexpr、synchronized","复合赋值运算符#复合赋值运算符":"运算符 示例表达式 说明 赋值结果 += c += 7 c = c + 7 c + 7 to c -= d -= 4 d = d - 4 d - 4 to d *= e *= 5 e = e * 5 e * 5 to e /= f /= 3 f = f / 3 f / 3 to f %= g %= 9 g = g % 9 g % 9 to g","循环#循环":"","条件判断#条件判断":"","注释#注释":"// 单行注释 /* 多行注释 */","相等性与关系运算符表#相等性与关系运算符表":"关系运算符 C++ 运算符 示例条件 含义 \u003e \u003e x \u003e y x 大于 y \u003c \u003c x \u003c y x 小于 y ≥ \u003e= x \u003e= y x 大于等于 y ≤ \u003c= x \u003c= y x 小于等于 y 相等性运算符 C++ 运算符 示例条件 含义 = == x == y x 等于 y ≠ != x != y x 不等于 y","系统#系统":"Windows MacOS Linux","编程范式#编程范式":"过程编程（使用控制语句） 函数式编程 对象编程 模板元编程（泛型编程）","编译器#编译器":"GNU C++ LLVM Clang++ Visual Studio C++","编辑器#编辑器":"vim vscode 各种 AI 编辑器（在 vscode 上修改的）","自增自减运算符#自增/自减运算符":"运算符 运算符名称 示例表达式 说明 ++ 前缀自增 ++number 先将 number 加 1，再在当前表达式中使用 number 的新值。 ++ 后缀自增 number++ 先在当前表达式中使用 number 的当前值，再将 number 加 1 -- 前缀自减 --number 先将 number 减 1，再在当前表达式中使用 number 的新值 -- 后缀自减 number-- 先在当前表达式中使用 number 的当前值，再将 number 减 1 运算符简单使用\n比较运算符示例：\n#include // 引入头文件 using std::cout; // using 整个文件使用std namespace下的 cout，不用每次都写std:: using std::cin; int main() { int number1{0}; int number2{0}; cout \u003c\u003c \"Enter two integers to compare: \"; cin \u003e\u003e number1 \u003e\u003e number2; if (number1 == number2) { // if 判断， == 相等 cout \u003c\u003c number1 \u003c\u003c \" == \" \u003c\u003c number2 \u003c\u003c \"\\n\"; } if (number1 != number2) { // != 不等 cout \u003c\u003c number1 \u003c\u003c \" != \" \u003c\u003c number2 \u003c\u003c \"\\n\"; } if (number1 \u003c number2) { // \u003c 小于 cout \u003c\u003c number1 \u003c\u003c \" \u003c \" \u003c\u003c number2 \u003c\u003c \"\\n\"; } if (number1 \u003e number2) { // \u003e 大于 cout \u003c\u003c number1 \u003c\u003c \" \u003e \" \u003c\u003c number2 \u003c\u003c \"\\n\"; } if (number1 \u003c= number2) { // \u003c= 小于等于 cout \u003c\u003c number1 \u003c\u003c \" \u003c= \" \u003c\u003c number2 \u003c\u003c \"\\n\"; } if (number1 \u003e= number2) { // \u003e= 大于等于 cout \u003c\u003c number1 \u003c\u003c \" \u003e= \" \u003c\u003c number2 \u003c\u003c \"\\n\"; } } 自增自减示例：\n#include using namespace std; int main() { int c{5}; cout \u003c\u003c \"c before postincrement: \" \u003c\u003c c \u003c\u003c \"\\n\"; // prints 5 cout \u003c\u003c \" postincrementing c: \" \u003c\u003c c++ \u003c\u003c \"\\n\"; // prints 5 cout \u003c\u003c \" c after postincrement: \" \u003c\u003c c \u003c\u003c \"\\n\"; // prints 6 cout \u003c\u003c \"\\n\"; c = 5; cout \u003c\u003c \" c before preincrement: \" \u003c\u003c c \u003c\u003c \"\\n\"; // prints 5 cout \u003c\u003c \" preincrementing c: \" \u003c\u003c ++c \u003c\u003c \"\\n\"; // prints 6 cout \u003c\u003c \" c after preincrement: \" \u003c\u003c c \u003c\u003c \"\\n\"; // prints 6 }","赋值#赋值":"列表初始化，可以防止窄化转换，等号赋值会隐式转换\nint a{12.7}; //会编译报错 int a = 12.7; //会隐式转换","转义字符#转义字符":"转义字符 说明 \\n 换行符 \\t 制表符 \\r 回车符 \\a 警告字符 \\\\ 反斜杠字符 \\' 单引号字符 \\\" 双引号字符","运算符#运算符":"整型类型、加号运算符示例：\n#include int main() { int number1{0}; // 列表初始化为 0，不初始化可能是个随机值， int 类型为整型变量 int number2{0}; int sum{0}; std::cout \u003c\u003c \"Enter first integer: \"; std::cin \u003e\u003e number1; // 标准输入 std::cin ，变量必须提前定义才能使用 std::cout \u003c\u003c \"Enter second integer: \"; std::cin \u003e\u003e number2; sum = number1 + number2; //右侧求和的结果赋值给左侧变量。 std::cout \u003c\u003c \"Sum is \" \u003c\u003c sum \u003c\u003c \"\\n\";// \\n 换行 }","逻辑运算符#逻辑运算符":"#include #include using namespace std; int main() { // \u0026\u0026 cout \u003c\u003c \"Logical AND (\u0026\u0026)\\n\" \u003c\u003c format(\"false \u0026\u0026 false: {}\\n\", false \u0026\u0026 false) \u003c\u003c format(\"false \u0026\u0026 true: {}\\n\", false \u0026\u0026 true) \u003c\u003c format(\"true \u0026\u0026 false: {}\\n\", true \u0026\u0026 false) \u003c\u003c format(\"true \u0026\u0026 true: {}\\n\\n\", true \u0026\u0026 true); // format 格式化不需要 boolalpha 自动就会显示文本，对于真假。 // || cout \u003c\u003c \"Logical OR (||)\\n\" \u003c\u003c format(\"false || false: {}\\n\", false || false) \u003c\u003c format(\"false || true: {}\\n\", false || true) \u003c\u003c format(\"true || false: {}\\n\", true || false) \u003c\u003c format(\"true || true: {}\\n\\n\", true || true); // ! cout \u003c\u003c \"Logical negation (!)\\n\" \u003c\u003c format(\"!false: {}\\n\", !false) \u003c\u003c format(\"!true: {}\\n\", !true); }","集成开发环境ide#集成开发环境（IDE）":"Visual Studio （Windows） CLion （全平台） XCode （MacOS）"},"title":"基础语法"},"/web/languages/cpp/%E5%9F%BA%E7%A1%80/02-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%952/":{"data":{"":"","double#double":"#include #include #include // 数学相关头文件 using namespace std; int main() { double principal{1000.00}; // 初始化 double 类型 double rate{0.05}; cout \u003c\u003c format(\"Initial principal: {:\u003e7.2f}\\n\", principal) \u003c\u003c format(\" Interest rate: {:\u003e7.2f}\\n\", rate); //格式化中占位符内容说明 : 格式说明符， \u003e 右对齐， 7 字段宽度字符数， 2 小数点位数， f浮点数类型 cout \u003c\u003c format(\"\\n{}{:\u003e20}\\n\", \"Year\", \"Amount on deposit\"); for (int year{1}; year \u003c= 10; ++year) { // pow 幂运算 double amount{principal * pow(1.0 + rate, year)} ; // d 十进制 cout \u003c\u003c format(\"{:\u003e4d}{:\u003e20.2f}\\n\", year, amount); } } 浮点数多精度可使用 boost 库的 cpp_dec_float_50 类，可参考：\ncpp_dec_float_50 查看源文件 ↗ 正在加载代码... https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/cpp/cpp_20_study/examples/lesson04/fig04_17.cpp\n❌ 加载失败 请检查网络连接或URL是否正确\n展开 折叠","inline-函数#inline 函数":"C++ Core Guidelines 原文 ISO C++ FAQ inline 函数的作用：\n可能提高性能。因为优化器可以在程序上集成调用的代码——将调用的代码优化到调用程序中。 inline函数可能会使其更快。 inline函数可能会使其变慢。 inline函数可能会使其变大。 inline函数可能会使其变小。 inline函数可能会导致粉碎。 inline函数可能会防止崩溃。 inline函数可能会增加缓存错过的次数。 inline函数可能会减少缓存错误的数量。 inline功能可能与速度无关。 inline 函数与宏的区别：\n安全：参数只求值一次，类型安全。宏在展开时会直接替换文本，导致传入的参数可能被计算多次。 可调试：在调试模式下可像普通函数一样调试（取决于编译器选项）。宏调试困难。 语义清晰：遵循 C++ 函数调用规则，行为可预测。宏不受作用域限制。 性能相当：现代编译器对 inline 函数的优化效果与宏相当，甚至更好（通过过程集成等优化）。 #include using namespace std; inline double cube(double side) { // inline func return side * side * side; // 返回立方值 } int main() { double sideValue; cout \u003c\u003c \"Enter the side length of your cube: \"; cin \u003e\u003e sideValue; cout \u003c\u003c \"Volume of cube with side \" \u003c\u003c sideValue \u003c\u003c \" is \" \u003c\u003c cube(sideValue) \u003c\u003c '\\n'; } [[nodiscard]] //C++17 引入，它是专门用于强制提醒开发者不要忽略函数返回值的标准化语法，核心作用是提升代码健壮性、避免因遗漏返回值导致的逻辑错误。 int cube(int x) { return x * x * x; } int main() { cube(10); // generates a compiler warning }","random#random":"#include #include using namespace std; int main() { // 随机数生成引擎（现在使用的是其中一种），需要种子才能随机，当前为伪随机 default_random_engine engine{}; // 指定的分布范围，概率都是相等的 uniform_int_distribution randomDie{1, 6}; // 10 次查看生成的结果 for (int counter{1}; counter \u003c= 10; ++counter) { cout \u003c\u003c randomDie(engine) \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; } #include #include using namespace std; int main() { unsigned int seed{0}; // 初始化一个种子 cout \u003c\u003c \"Enter seed: \"; cin \u003e\u003e seed; default_random_engine engine{seed}; // 使用种子 //random_device rd; // 随机设备对象 //default_random_engine engine{rd()}; // rd() produces a seed uniform_int_distribution randomDie{1, 6}; for (int counter{1}; counter \u003c= 10; ++counter) { cout \u003c\u003c randomDie(engine) \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; }","vigenère-密码#Vigenère 密码":"Vigenère 密码（Vignère secret key cipher）：一种多表替换密码，通过使用一系列凯撒密码组成加密字母表来加密明文，是古典密码学中最著名的算法之一。 链接 主题 https://en.wikipedia.org/wiki/Vigenère_cipher Vigenère 密码的详细原理、历史和破解方法 https://en.wikipedia.org/wiki/Cryptography#History_of_cryptography_and_cryptanalysis 密码学的完整历史，从古典密码到现代密码学的演变 https://www.binance.vision/security/history-of-cryptography 以区块链和加密货币为背景的密码学历史介绍 在线凯撒密码工具 在线凯撒密码工具 cryptii 开源工具 示例代码参考：\nVigenère 密码示例 查看源文件 ↗ 正在加载代码... https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/cpp/cpp_20_study/examples/lesson05/fig05_18.cpp\n❌ 加载失败 请检查网络连接或URL是否正确\n展开 折叠","作用域#作用域":"static 静态局部变量在第一次初始化后保存在内存，以后可重复利用不需要再初始化 局部变量作用域结束后即销毁 全局变量在整个程序的运行时期都有效 #include using namespace std; void useLocal(); void useStaticLocal(); void useGlobal(); int x{1}; //全局变量 int main() { cout \u003c\u003c \"global x in main is \" \u003c\u003c x \u003c\u003c '\\n'; const int x{5};// main 函数内局部变量 cout \u003c\u003c \"local x in main's outer scope is \" \u003c\u003c x \u003c\u003c '\\n'; { const int x{7}; //块内局部变量 cout \u003c\u003c \"local x in main's inner scope is \" \u003c\u003c x \u003c\u003c '\\n'; } cout \u003c\u003c \"local x in main's outer scope is \" \u003c\u003c x \u003c\u003c '\\n'; useLocal(); useStaticLocal(); useGlobal(); useLocal(); useStaticLocal(); useGlobal(); cout \u003c\u003c \"\\nlocal x in main is \" \u003c\u003c x \u003c\u003c '\\n'; } void useLocal() { int x{25}; // useLocal 函数内局部变量 cout \u003c\u003c \"\\nlocal x is \" \u003c\u003c x \u003c\u003c \" on entering useLocal\\n\"; ++x; cout \u003c\u003c \"local x is \" \u003c\u003c x \u003c\u003c \" on exiting useLocal\\n\"; } void useStaticLocal() { static int x{50}; //静态局部变量，第一次调用，则保存在内存，直到程序结束，只能在这个函数内调用此变量。 cout \u003c\u003c \"\\nlocal static x is \" \u003c\u003c x \u003c\u003c \" on entering useStaticLocal\\n\"; ++x; cout \u003c\u003c \"local static x is \" \u003c\u003c x \u003c\u003c \" on exiting useStaticLocal\\n\"; } void useGlobal() { cout \u003c\u003c \"\\nglobal x is \" \u003c\u003c x \u003c\u003c \" on entering useGlobal\\n\"; x *= 10; //使用全局变量 cout \u003c\u003c \"global x is \" \u003c\u003c x \u003c\u003c \" on exiting useGlobal\\n\"; }","值传递#值传递":"拷贝副本\n#include using namespace std; int squareByValue(int number); int main() { int x{2}; cout \u003c\u003c \"x = \" \u003c\u003c x \u003c\u003c \" before squareByValue\\n\"; cout \u003c\u003c \"Value returned by squareByValue: \" \u003c\u003c squareByValue(x) \u003c\u003c '\\n'; cout \u003c\u003c \"x = \" \u003c\u003c x \u003c\u003c \" after squareByValue\\n\\n\"; } int squareByValue(int number) { return number *= number; }","函数#函数":"cmath C++ standard document math function cmath 头文件中的部分函数说明","函数参数#函数参数":"","函数模板#函数模板":"可以自动接收不同参数类型，不需要写多个不同类型的重复代码\n#include using namespace std; template \u003ctypename T\u003e // or template T maximum(T value1, T value2, T value3) { T maximumValue{value1}; if (value2 \u003e maximumValue) { maximumValue = value2; } if (value3 \u003e maximumValue) { maximumValue = value3; } return maximumValue; } int main() { cout \u003c\u003c \"Input three integer values: \"; int int1, int2, int3; cin \u003e\u003e int1 \u003e\u003e int2 \u003e\u003e int3; cout \u003c\u003c \"The maximum integer value is: \" \u003c\u003c maximum(int1, int2, int3); cout \u003c\u003c \"\\n\\nInput three double values: \"; double double1, double2, double3; cin \u003e\u003e double1 \u003e\u003e double2 \u003e\u003e double3; cout \u003c\u003c \"The maximum double value is: \" \u003c\u003c maximum(double1, double2, double3); cout \u003c\u003c \"\\n\\nInput three characters: \"; char char1, char2, char3; cin \u003e\u003e char1 \u003e\u003e char2 \u003e\u003e char3; cout \u003c\u003c \"The maximum character value is: \" \u003c\u003c maximum(char1, char2, char3) \u003c\u003c '\\n'; }","函数重载#函数重载":"函数的返回值不区分函数签名，所以不是重载的条件。 cppreference 对重载决议有完整的规则说明 编译器底层会对函数名重整，编译器不同,重整方式不同，一般会把函数参数加到函数名中用于区分调用的函数。 #include using namespace std; int square(int x) { cout \u003c\u003c \"square of integer \" \u003c\u003c x \u003c\u003c \" is \"; return x * x; } double square(double y) { cout \u003c\u003c \"square of double \" \u003c\u003c y \u003c\u003c \" is \"; return y * y; } int main() { cout \u003c\u003c square(7); cout \u003c\u003c '\\n'; cout \u003c\u003c square(7.5); cout \u003c\u003c '\\n'; }","基础数据类型列表#基础数据类型列表":"types\nData types Notes long double double float unsigned long long int (synonymous with unsigned long long) long long int (synonymous with long long) unsigned long int (synonymous with unsigned long) long int (synonymous with long) unsigned int (synonymous with unsigned) int unsigned short int (synonymous with unsigned short) short int (synonymous with short) unsigned char char and signed char bool","字符串#字符串":"#include #include // 引入字符串头文件 using namespace std; //引入 std 命名空间，这样标准空间中其他方法不需要都写上命名空间 int main() { string s1{\"happy\"}; // 字符串初始化为 happy string s2{\" birthday\"}; string s3; // 空字符串 cout \u003c\u003c \"s1: \\\"\" \u003c\u003c s1 \u003c\u003c \"\\\"; length: \" \u003c\u003c s1.length() \u003c\u003c \"\\ns2: \\\"\" \u003c\u003c s2 \u003c\u003c \"\\\"; length: \" \u003c\u003c s2.length() \u003c\u003c \"\\ns3: \\\"\" \u003c\u003c s3 \u003c\u003c \"\\\"; length: \" \u003c\u003c s3.length(); // 字符串比较 == and != cout \u003c\u003c \"\\n\\nThe results of comparing s2 and s1:\" \u003c\u003c boolalpha //由于C++比较的结果为数字，所以增加这个变量可以显示false，or true。 \u003c\u003c \"\\ns2 == s1: \" \u003c\u003c (s2 == s1) \u003c\u003c \"\\ns2 != s1: \" \u003c\u003c (s2 != s1); //比较值显示 0 为 false ，非 0 为true cout \u003c\u003c \"\\n\\nTesting s3.empty():\\n\"; if (s3.empty()) { // 字符串判断是否为空 cout \u003c\u003c \"s3 is empty; assigning to s3;\\n\"; s3 = s1 + s2; // 字符串拼接 cout \u003c\u003c \"s3: \\\"\" \u003c\u003c s3 \u003c\u003c \"\\\"\"; } cout \u003c\u003c \"\\n\\ns1 starts with \\\"ha\\\": \" \u003c\u003c s1.starts_with(\"ha\") \u003c\u003c \"\\n\"; //判断字符串是否以 ha 开头 cout \u003c\u003c \"s2 starts with \\\"ha\\\": \" \u003c\u003c s2.starts_with(\"ha\") \u003c\u003c \"\\n\"; cout \u003c\u003c \"s1 ends with \\\"ay\\\": \" \u003c\u003c s1.ends_with(\"ay\") \u003c\u003c \"\\n\";//判断字符串是否以 ay 结尾 cout \u003c\u003c \"s2 ends with \\\"ay\\\": \" \u003c\u003c s2.ends_with(\"ay\") \u003c\u003c \"\\n\"; //boolalpha 设置依然有效，这是粘性设置。 cout \u003c\u003c noboolalpha \u003c\u003c \"s1 starts with \\\"ha\\\": \" \u003c\u003c s1.starts_with(\"ha\") \u003c\u003c \"\\n\"; //noboolalpha 取消设置 true or false 文本显示。 } //g++ string_test.cpp --std=c++20 //需要指定C++20，否则会报错，默认非20标准","常用数学函数表#常用数学函数表":"Function Description Example ceil(x) 向上取整，返回不小于 x 的最小整数 ceil(9.2) is 10.0\nceil(-9.8) is -9.0 cos(x) 计算 x 的余弦值（x 以弧度为单位） cos(0.0) is 1.0 exp(x) 计算指数函数 (e^x) exp(1.0) is 2.718282\nexp(2.0) is 7.389056 fabs(x) 计算 x 的绝对值 fabs(5.1) is 5.1\nfabs(0.0) is 0.0\nfabs(-8.76) is 8.76 floor(x) 向下取整，返回不大于 x 的最大整数 floor(9.2) is 9.0\nfloor(-9.8) is -10.0 fmod(x, y) 计算 x 除以 y 的浮点数余数 fmod(2.6, 1.2) is 0.2 log(x) 计算 x 的自然对数（以 e 为底） log(2.718282) is 1.0\nlog(7.389056) is 2.0 log10(x) 计算 x 的常用对数（以 10 为底） log10(10.0) is 1.0\nlog10(100.0) is 2.0 pow(x, y) 计算 x 的 y 次幂（(x^y)） pow(2, 7) is 128\npow(9, .5) is 3 sin(x) 计算 x 的正弦值（x 以弧度为单位） sin(0.0) is 0 sqrt(x) 计算 x 的平方根（x 必须非负） sqrt(9.0) is 3.0 tan(x) 计算 x 的正切值（x 以弧度为单位） tan(0.0) is 0 #include using namespace std; int maximum(int x, int y, int z); // 函数前置声明 int main() { cout \u003c\u003c \"Enter three integer values: \"; int int1, int2, int3; cin \u003e\u003e int1 \u003e\u003e int2 \u003e\u003e int3; cout \u003c\u003c \"The maximum integer value is: \" \u003c\u003c maximum(int1, int2, int3) \u003c\u003c '\\n'; } //函数实现 int maximum(int x, int y, int z) { int maximumValue{x}; // 初始化变量 if (y \u003e maximumValue) { maximumValue = y; } if (z \u003e maximumValue) { maximumValue = z; } return maximumValue; }","引用传递#引用传递":"传递地址，减少数据拷贝\n#include using namespace std; void squareByReference(int\u0026 numberRef); int main() { int z{4}; cout \u003c\u003c \"z = \" \u003c\u003c z \u003c\u003c \" before squareByReference\\n\"; squareByReference(z); cout \u003c\u003c \"z = \" \u003c\u003c z \u003c\u003c \" after squareByReference\\n\"; } void squareByReference(int\u0026 numberRef) { numberRef *= numberRef; }","类型#类型":"","超大整数可使用的第三方库#超大整数可使用的第三方库":"multiprecision\n使用 cpp_int 类\n#include #include using namespace std; using boost::multiprecision::cpp_int; int main() { const cpp_int value1{\"100000000000000000000000000000\"}; const cpp_int value2{9223372036854775807LL};//这个long long整数最大值可以通过 std::numeric_limits::max()自动获取最大值，头文件在 limits下 const int value3{3}; cout \u003c\u003c \"INITIAL VALUES\" \u003c\u003c \"\\ncpp_int value1: \" \u003c\u003c value1 \u003c\u003c \"\\ncpp_int value2: \" \u003c\u003c value2 \u003c\u003c \"\\n int value3: \" \u003c\u003c value3; cout \u003c\u003c \"\\n\\nADD, SUBTRACT AND MULTIPLY CPP_INT OBJECTS\" \u003c\u003c \"\\nvalue1 + value2: \" \u003c\u003c value1 + value2 \u003c\u003c \"\\nvalue1 - value2: \" \u003c\u003c value1 - value2 \u003c\u003c \"\\nvalue1 * value2: \" \u003c\u003c value1 * value2; cout \u003c\u003c \"\\n\\nMULTIPLY A CPP_INT OBJECT BY INT VALUES\" \u003c\u003c \"\\nvalue1 * value3: \" \u003c\u003c value1 * value3 \u003c\u003c \"\\n value1 * 17: \" \u003c\u003c value1 * 17 \u003c\u003c \"\\n\"; }","递归#递归":"斐波拉契数列：\n#include #include using namespace std; long fibonacci(long number); int main() { for (int counter{0}; counter \u003c= 10; ++counter) { cout \u003c\u003c format(\"fibonacci({}) = {}\\n\", counter, fibonacci(counter)); } cout \u003c\u003c format(\"\\nfibonacci(20) = {}\\n\", fibonacci(20)) \u003c\u003c format(\"fibonacci(30) = {}\\n\", fibonacci(30)) \u003c\u003c format(\"fibonacci(35) = {}\\n\", fibonacci(35)); } long fibonacci(long number) { if ((0 == number) || (1 == number)) { return number; } else { return fibonacci(number - 1) + fibonacci(number - 2); } } cpp_int 阶乘参考：\ncpp_int 阶乘 查看源文件 ↗ 正在加载代码... https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/cpp/cpp_20_study/examples/lesson05/fig05_14.cpp\n❌ 加载失败 请检查网络连接或URL是否正确\n展开 折叠","默认实参#默认实参":"有默认实参值，不传递参数值，则使用默认参数值 默认实参在定义时指定即可，实现时参数不需要指定参数值 #include using namespace std; int boxVolume(int length = 1, int width = 1, int height = 1); int main() { cout \u003c\u003c \"The default box volume is: \" \u003c\u003c boxVolume(); cout \u003c\u003c \"\\n\\nThe volume of a box with length 10,\\n\" \u003c\u003c \"width 1 and height 1 is: \" \u003c\u003c boxVolume(10); cout \u003c\u003c \"\\n\\nThe volume of a box with length 10,\\n\" \u003c\u003c \"width 5 and height 1 is: \" \u003c\u003c boxVolume(10, 5); cout \u003c\u003c \"\\n\\nThe volume of a box with length 10,\\n\" \u003c\u003c \"width 5 and height 2 is: \" \u003c\u003c boxVolume(10, 5, 2) \u003c\u003c '\\n'; } int boxVolume(int length, int width, int height) { return length * width * height; }"},"title":"基础语法2"},"/web/languages/cpp/%E5%9F%BA%E7%A1%80/03-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%953/":{"data":{"":"","accumulate#accumulate":"#include #include #include #include //数学相关函数的头文件 int main() { constexpr std::array integers{10, 20, 30, 40}; std::cout \u003c\u003c std::format(\"Total of array elements: {}\\n\", std::accumulate(std::begin(integers), std::end(integers), 0)); //数组中内容求和 }","array#array":"#include #include #include int main() { std::array\u003cint, 5\u003e values; // 初始化 5 大小的数组 for (size_t i{0}; i \u003c values.size(); ++i) {// size_t 无符号整数类型 values[i] = 0; // 赋值为0 } std::cout \u003c\u003c std::format(\"{:\u003e7}{:\u003e10}\\n\", \"Element\", \"Value\"); for (size_t i{0}; i \u003c values.size(); ++i) { std::cout \u003c\u003c std::format(\"{:\u003e7}{:\u003e10}\\n\", i, values[i]);//[] 取值 } std::cout \u003c\u003c std::format(\"\\n{:\u003e7}{:\u003e10}\\n\", \"Element\", \"Value\"); for (size_t i{0}; i \u003c values.size(); ++i) { std::cout \u003c\u003c std::format(\"{:\u003e7}{:\u003e10}\\n\", i, values.at(i));//at 取值 } values.at(10); // 超过数组大小，异常 std::array\u003cint, 5\u003e values{32, 27, 64, 18, 95}; // 初始化为 int 类型 for (size_t i{0}; i \u003c values.size(); ++i) { std::cout \u003c\u003c std::format(\"{} \", values.at(i));// at 取值，{} 占位符 } std::cout \u003c\u003c \"\\n\\n\"; std::array values2{1.1, 2.2, 3.3, 4.4}; // 根据初始化值类型自动推导为 double 类型，大小为4，与 std::array value2{1.1, 2.2, 3.3, 4.4} 相同 for (size_t i{0}; i \u003c values2.size(); ++i) { std::cout \u003c\u003c std::format(\"{} \", values2.at(i)); } std::cout \u003c\u003c '\\n'; } for 遍历\n#include #include #include int main() { std::array items{1, 2, 3, 4, 5}; // 同 array std::cout \u003c\u003c \"items before modification: \"; for (const int\u0026 item : items) { // const reference std::cout \u003c\u003c std::format(\"{} \", item); } for (int\u0026 item : items) { // reference item *= 2; //修改 item 的值 } std::cout \u003c\u003c \"\\nitems after modification: \"; for (const int\u0026 item : items) { std::cout \u003c\u003c std::format(\"{} \", item); } std::cout \u003c\u003c \"\\n\\ncalculating a running total of items' values:\\n\"; for (int runningTotal{0}; const int\u0026 item : items) { runningTotal += item; std::cout \u003c\u003c std::format(\"item: {}; running total: {}\\n\", item, runningTotal); } } #include #include #include int main() { constexpr size_t arraySize{5}; // 常量表达式，constexpr 在编译时处理，必须初始化 std::array\u003cint, arraySize\u003e values{}; for (int i{0}; i \u003c values.size(); ++i) { //遍历赋值。 values.at(i) = 2 + 2 * i; } for (const int\u0026 value : values) { std::cout \u003c\u003c std::format(\"{} \", value); } std::cout \u003c\u003c '\\n'; } #include #include // contains sort and binary_search #include #include #include int main() { using namespace std::string_literals; // std::string_literals 是 C++14 标准库中的一个内联命名空间，核心作用是：为字符串字面量提供 s 后缀，让双引号包裹的字符串直接生成 std::string 对象，而非传统的 const char* 字符数组 // array， 这里自动推导，可以推导成 string 类型，而不是指针 std::array colors{\"red\"s, \"orange\"s, \"yellow\"s, \"green\"s, \"blue\"s, \"indigo\"s, \"violet\"s}; // C 风格字符串， 字符串对象字面量 std::cout \u003c\u003c \"Unsorted colors array:\\n \"; for (const std::string\u0026 color : colors) { std::cout \u003c\u003c std::format(\"{} \", color); } // 排序 std::sort(std::begin(colors), std::end(colors)); std::cout \u003c\u003c \"\\nSorted colors array:\\n \"; for (const std::string\u0026 color : colors) { std::cout \u003c\u003c std::format(\"{} \", color); } // 二分查找 indigo bool found{std::binary_search( std::begin(colors), std::end(colors), \"indigo\")}; std::cout \u003c\u003c std::format(\"\\n\\n\\\"indigo\\\" {} found in colors array\\n\", found ? \"was\" : \"was not\"); // 二分查找 \"cyan\" found = std::binary_search( std::begin(colors), std::end(colors), \"cyan\"); std::cout \u003c\u003c std::format(\"\\\"cyan\\\" {} found in colors array\\n\", found ? \"was\" : \"was not\"); } 二维数组\n#include #include constexpr size_t rows{2}; constexpr size_t columns{3}; void printArray(const std::array\u003cstd::array\u003cint, columns\u003e, rows\u003e\u0026 a); int main() { constexpr std::array values1{std::array{1, 2, 3}, std::array{4, 5, 6}}; // 自动推导 constexpr std::array values2{std::array{1, 2, 3}, std::array{4, 5, 0}}; std::cout \u003c\u003c \"values1 by row:\\n\"; printArray(values1); std::cout \u003c\u003c \"\\nvalues2 by row:\\n\"; printArray(values2); } void printArray(const std::array\u003cstd::array\u003cint, columns\u003e, rows\u003e\u0026 a) { for (const auto\u0026 row : a) { for (const auto\u0026 element : row) { std::cout \u003c\u003c element \u003c\u003c ' '; } std::cout \u003c\u003c '\\n'; // start new line of output } }","ranges-库相关函数#ranges 库相关函数":"#include #include #include #include #include int main() { auto showValues{ [](auto\u0026 values, const std::string\u0026 message) { std::cout \u003c\u003c std::format(\"{}: \", message); for (const auto\u0026 value : values) { std::cout \u003c\u003c std::format(\"{} \", value); } std::cout \u003c\u003c '\\n'; } }; //使用花括号定义一个匿名函数表达式的参数赋值。 auto values1{std::views::iota(1, 11)}; // views::iota 随机生成整数 1-10，前闭后开 showValues(values1, \"Generate integers 1-10\"); // filter 过滤元素，只保留符合元素的，| 可以认为管道 auto values2{values1 | std::views::filter([](const auto\u0026 x) {return x % 2 == 0;})}; showValues(values2, \"Filtering even integers\"); // transform 映射，不会改变元素数量 auto values3{ values2 | std::views::transform([](const auto\u0026 x) {return x * x;})}; showValues(values3, \"Mapping even integers to squares\"); // 组合前面几步，将 1-10 中的偶数求平方。 auto values4{ values1 | std::views::filter([](const auto\u0026 x) {return x % 2 == 0;}) | std::views::transform([](const auto\u0026 x) {return x * x; })}; showValues(values4, \"Squares of even integers\"); // 求和 std::cout \u003c\u003c std::format(\"Sum squares of even integers 2-10: {}\\n\", std::accumulate(std::begin(values4), std::end(values4), 0)); // 自定义的数组与 iota 随机生成的比较 constexpr std::array numbers{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; auto values5{ numbers | std::views::filter([](const auto\u0026 x) {return x % 2 == 0;}) | std::views::transform([](const auto\u0026 x) {return x * x;})}; showValues(values5, \"Squares of even integers in array numbers\"); }","stl#stl":"","vector#vector":"at 函数获取值会做异常检查，[]获取可能出现异常错误。 可动态扩容，确定个数，指定个数性能会更好。 #include #include #include void outputVector(const std::vector\u003cint\u003e\u0026 items); void inputVector(std::vector\u003cint\u003e\u0026 items); int main() { std::vector\u003cint\u003e integers1(7); //7个元素个数，默认值为0 std::vector\u003cint\u003e integers2(10); // 10个元素个数，默认值为0 std::cout \u003c\u003c \"Size of vector integers1 is \" \u003c\u003c integers1.size() \u003c\u003c \"\\nvector after initialization: \"; outputVector(integers1); std::cout \u003c\u003c \"\\nSize of vector integers2 is \" \u003c\u003c integers2.size() \u003c\u003c \"\\nvector after initialization: \"; outputVector(integers2); std::cout \u003c\u003c \"\\nEnter 17 integers:\\n\"; inputVector(integers1); inputVector(integers2); std::cout \u003c\u003c \"\\nAfter input, the vectors contain:\\n\" \u003c\u003c \"integers1: \"; outputVector(integers1); std::cout \u003c\u003c \"integers2: \"; outputVector(integers2); std::cout \u003c\u003c \"\\nEvaluating: integers1 != integers2\\n\"; if (integers1 != integers2) { std::cout \u003c\u003c \"integers1 and integers2 are not equal\\n\"; } std::vector integers3{integers1};//拷贝构造 std::cout \u003c\u003c \"\\nSize of vector integers3 is \" \u003c\u003c integers3.size() \u003c\u003c \"\\nvector after initialization: \"; outputVector(integers3); std::cout \u003c\u003c \"\\nAssigning integers2 to integers1:\\n\"; integers1 = integers2; //使用赋值重载运算符 std::cout \u003c\u003c \"integers1: \"; outputVector(integers1); std::cout \u003c\u003c \"integers2: \"; outputVector(integers2); std::cout \u003c\u003c \"\\nEvaluating: integers1 == integers2\\n\"; if (integers1 == integers2) { //使用比较运算符 == std::cout \u003c\u003c \"integers1 and integers2 are equal\\n\"; } std::cout \u003c\u003c \"\\nintegers1.at(5) is \" \u003c\u003c integers1.at(5); std::cout \u003c\u003c \"\\n\\nAssigning 1000 to integers1.at(5)\\n\"; integers1.at(5) = 1000; //可以使用赋值操作给 at的索引值 std::cout \u003c\u003c \"integers1: \"; outputVector(integers1); try { std::cout \u003c\u003c \"\\nAttempt to display integers1.at(15)\\n\"; std::cout \u003c\u003c integers1.at(15) \u003c\u003c '\\n'; } catch (const std::out_of_range\u0026 ex) { std::cerr \u003c\u003c \"An exception occurred: \" \u003c\u003c ex.what() \u003c\u003c '\\n'; } std::cout \u003c\u003c \"\\nCurrent integers3 size is: \" \u003c\u003c integers3.size(); //vector 的长度。 integers3.push_back(1000); // 尾部追加值 1000 std::cout \u003c\u003c \"\\nNew integers3 size is: \" \u003c\u003c integers3.size() \u003c\u003c \"\\nintegers3 now contains: \"; outputVector(integers3); } // for 遍历 vector 内容 void outputVector(const std::vector\u003cint\u003e\u0026 items) { for (const int\u0026 item : items) { std::cout \u003c\u003c item \u003c\u003c ' '; } std::cout \u003c\u003c '\\n'; } // 终端输入数据 void inputVector(std::vector\u003cint\u003e\u0026 items) { for (int\u0026 item : items) { std::cin \u003e\u003e item; } }","标准库函数#标准库函数":""},"title":"基础语法3"},"/web/languages/cpp/%E6%8F%90%E9%AB%98/01-basic/":{"data":{"1-提示块-callout#1. 提示块 (Callout)":"记录注意事项非常有用：\nNote\n这里的 std::move 并没有真正移动内存，只是进行了类型转换。\nWarning\n永远不要返回局部变量的引用！","2-代码高亮#2. 代码高亮":"#include int main() { std::cout \u003c\u003c \"Hello Hextra!\" \u003c\u003c std::endl; return 0; } 点击查看详细源码 // 很长的代码... void longFunction() { // ... }","深入理解指针#深入理解指针":"深入理解指针这里是正文…","特色功能演示#特色功能演示":""},"title":"C++ 指针与引用"},"/web/languages/cpp/%E6%8F%90%E9%AB%98/02-stl/":{"data":{"list#list":"双向链表，支持高效的插入和删除：\n#include std::list\u003cint\u003e myList = {1, 2, 3}; myList.push_front(0); // 在前面插入 myList.push_back(4); // 在后面插入","map#map":"键值对容器，自动排序：\n#include #include std::map\u003cstd::string, int\u003e scores; scores[\"Alice\"] = 95; scores[\"Bob\"] = 87; Tip\n使用 unordered_map 可以获得更好的查找性能，但不保证顺序。","pop_back#pop_back()":"","push_back#push_back()":"","stl-容器深入解析#STL 容器深入解析":"STL 容器深入解析STL（Standard Template Library）是C++标准库的重要组成部分，提供了丰富的容器类型。","vector#vector":"动态数组，支持随机访问：\n#include #include int main() { std::vector\u003cint\u003e vec = {1, 2, 3, 4, 5}; // 添加元素 vec.push_back(6); // 遍历 for (const auto\u0026 item : vec) { std::cout \u003c\u003c item \u003c\u003c \" \"; } return 0; }","优先队列实现#优先队列实现":"以下是一个完整的优先队列实现示例：\n优先队列完整实现 查看源文件 ↗ 正在加载代码... https://raw.githubusercontent.com/cold-rivers-snow/recipes/master/datastruct/priority_queue.cpp\n❌ 加载失败 请检查网络连接或URL是否正确\n展开 折叠","关联容器#关联容器":"","实战示例#实战示例":"","序列容器#序列容器":""},"title":"C++ STL 容器详解"},"/web/languages/cpp/%E6%8F%90%E9%AB%98/03-memory/":{"data":{"c-内存管理详解#C++ 内存管理详解":"C++ 内存管理详解内存管理是C++编程的核心技能之一，正确的内存管理能避免内存泄漏和悬空指针等问题。","raii原则#RAII原则":"Resource Acquisition Is Initialization - 资源获取即初始化：\nclass FileHandler { private: FILE* file; public: FileHandler(const char* filename) { file = fopen(filename, \"r\"); if (!file) throw std::runtime_error(\"Cannot open file\"); } ~FileHandler() { if (file) fclose(file); } // 禁止拷贝 FileHandler(const FileHandler\u0026) = delete; FileHandler\u0026 operator=(const FileHandler\u0026) = delete; }; Warning\n避免使用裸指针进行动态内存管理，优先使用智能指针。","shared_ptr#shared_ptr":"共享所有权的智能指针：\nstd::shared_ptr\u003cint\u003e ptr1 = std::make_shared\u003cint\u003e(100); std::shared_ptr\u003cint\u003e ptr2 = ptr1; // 引用计数增加 // 当最后一个shared_ptr销毁时，内存才会被释放","unique_ptr#unique_ptr":"独占所有权的智能指针：\n#include std::unique_ptr\u003cint\u003e ptr = std::make_unique\u003cint\u003e(42); // 自动管理内存，无需手动delete","weak_ptr#weak_ptr":"解决循环引用问题：\nstd::weak_ptr\u003cint\u003e weak = ptr1; if (auto locked = weak.lock()) { // 安全访问对象 std::cout \u003c\u003c *locked \u003c\u003c std::endl; }","智能指针#智能指针":""},"title":"C++ 内存管理"},"/web/languages/cpp/%E6%8F%90%E9%AB%98/04-cpu/":{"data":{"c-内存管理详解#C++ 内存管理详解":"C++ 内存管理详解内存管理是C++编程的核心技能之一，正确的内存管理能避免内存泄漏和悬空指针等问题。","raii原则#RAII原则":"Resource Acquisition Is Initialization - 资源获取即初始化：\nclass FileHandler { private: FILE* file; public: FileHandler(const char* filename) { file = fopen(filename, \"r\"); if (!file) throw std::runtime_error(\"Cannot open file\"); } ~FileHandler() { if (file) fclose(file); } // 禁止拷贝 FileHandler(const FileHandler\u0026) = delete; FileHandler\u0026 operator=(const FileHandler\u0026) = delete; }; Warning\n避免使用裸指针进行动态内存管理，优先使用智能指针。","shared_ptr#shared_ptr":"共享所有权的智能指针：\nstd::shared_ptr\u003cint\u003e ptr1 = std::make_shared\u003cint\u003e(100); std::shared_ptr\u003cint\u003e ptr2 = ptr1; // 引用计数增加 // 当最后一个shared_ptr销毁时，内存才会被释放","unique_ptr#unique_ptr":"独占所有权的智能指针：\n#include std::unique_ptr\u003cint\u003e ptr = std::make_unique\u003cint\u003e(42); // 自动管理内存，无需手动delete","weak_ptr#weak_ptr":"解决循环引用问题：\nstd::weak_ptr\u003cint\u003e weak = ptr1; if (auto locked = weak.lock()) { // 安全访问对象 std::cout \u003c\u003c *locked \u003c\u003c std::endl; }","智能指针#智能指针":""},"title":"C++ CPU"},"/web/languages/rust/ownership/":{"data":{"rust-所有权系统详解#Rust 所有权系统详解":"Rust 所有权系统详解所有权（Ownership）是Rust最独特的特性，它使Rust能够在不使用垃圾回收的情况下保证内存安全。","不可变引用#不可变引用":"fn main() { let s1 = String::from(\"hello\"); let len = calculate_length(\u0026s1); // 借用s1 println!(\"The length of '{}' is {}.\", s1, len); // s1仍然有效 } fn calculate_length(s: \u0026String) -\u003e usize { s.len() }","借用和引用#借用和引用":"","可变引用#可变引用":"fn main() { let mut s = String::from(\"hello\"); change(\u0026mut s); println!(\"{}\", s); // 输出: hello, world } fn change(some_string: \u0026mut String) { some_string.push_str(\", world\"); }","所有权规则#所有权规则":"Rust中的每一个值都有一个被称为其所有者（owner）的变量 值在任一时刻有且只有一个所有者 当所有者离开作用域，这个值将被丢弃","生命周期#生命周期":"生命周期确保引用有效的时间不会超过其引用的数据：\nfn longest\u003c'a\u003e(x: \u0026'a str, y: \u0026'a str) -\u003e \u0026'a str { if x.len() \u003e y.len() { x } else { y } } Note\n所有权系统在编译时检查内存安全，运行时没有额外开销。","移动语义#移动语义":"fn main() { let s1 = String::from(\"hello\"); let s2 = s1; // s1的值移动到s2，s1不再有效 // println!(\"{}\", s1); // 编译错误！s1已经无效 println!(\"{}\", s2); // 正确 }"},"title":"Rust 所有权系统"},"/web/languages/rust/pattern-matching/":{"data":{"if-let-语法糖#if let 语法糖":"当只关心一个模式时，可以使用if let：\nlet some_u8_value = Some(0u8); // 使用 match match some_u8_value { Some(3) =\u003e println!(\"three\"), _ =\u003e (), } // 使用 if let，更简洁 if let Some(3) = some_u8_value { println!(\"three\"); }","match-表达式#match 表达式":"","option-枚举匹配#Option 枚举匹配":"fn plus_one(x: Option\u003ci32\u003e) -\u003e Option\u003ci32\u003e { match x { None =\u003e None, Some(i) =\u003e Some(i + 1), } } let five = Some(5); let six = plus_one(five); let none = plus_one(None);","rust-模式匹配#Rust 模式匹配":"Rust 模式匹配模式匹配是Rust中非常强大的特性，通过match表达式和其他模式匹配语法，可以编写简洁而安全的代码。","while-let-循环#while let 循环":"let mut stack = Vec::new(); stack.push(1); stack.push(2); stack.push(3); while let Some(top) = stack.pop() { println!(\"{}\", top); } Tip\n模式匹配必须是穷尽的，编译器会检查所有可能的情况都被处理。","基本用法#基本用法":"enum Coin { Penny, Nickel, Dime, Quarter, } fn value_in_cents(coin: Coin) -\u003e u8 { match coin { Coin::Penny =\u003e 1, Coin::Nickel =\u003e 5, Coin::Dime =\u003e 10, Coin::Quarter =\u003e 25, } }","绑定值的模式#绑定值的模式":"#[derive(Debug)] enum UsState { Alabama, Alaska, // --snip-- } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn value_in_cents(coin: Coin) -\u003e u8 { match coin { Coin::Penny =\u003e 1, Coin::Nickel =\u003e 5, Coin::Dime =\u003e 10, Coin::Quarter(state) =\u003e { println!(\"State quarter from {:?}!\", state); 25 } } }"},"title":"Rust 模式匹配"}}